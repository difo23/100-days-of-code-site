{"componentChunkName":"component---src-components-day-template-js","path":"/day-16","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Dynamic programming and memoization","day":"16","publishDate":"2020-08-24","shareText":"Day 16/100  Daily Coding Problem: Dynamic programming and memoization technique with factorial and Pascal triangle.","hashtags":["100DaysOfCode","javascript","algorithms","memoization","interview","dynamic","programming","pascal","triangle","recursive"],"thumbnailImage":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABp0lEQVQoz32SaZOaQBCGh13UlcMBuW9mgJFDbnUVsrrm//+oDOaDSUpS9VRXf3mqu+cdsLQLOT5SRNRtoh7GByk5baLDBKqFsHozdoz+GvDh1Cr+oaCzGJx4PGyiQSI3SO5ifJWjXPDJnDnJrJ1ywU70Ot6vFHJcO+UKNRpptLBijRxoBGjz8tLO+CDj3Ybz6g3qllax8ioxrGDQLKz9u5mxZvZupDNru5mcZCYZdTyqeHCKu0WuavKtpjcpucp4tOIBoh5oySvZy/SskPJWwkcluhgV1b708u7Un5B8QVQvbTp2bvJDhnkjxJ0dfVvRTfD6RbBfRz0XfkJcLiwC1IROpscDfeKFLOJOC0c5PsCkhW4vuURDF+ifpbBbORW9nx6/MFPWTP+Rc5i3MOx0NFjNXcuuRvVT35+2yahnA71CwBcpHtZuKVL8gkbwlLU8n9aOesFuoXcUnPYD1Vzcc+gMo4q+KFDJlNlj5z+TA6xJeC8R/JwxYkYJwdafkAMg0fpolJBR0RPl2QPW2ilJqeAD2OI3nfyG+bsyNKdXgJWdsvO/9//8AqSPUK8fq+X5AAAAAElFTkSuQmCC","aspectRatio":1.492537313432836,"src":"/static/c8949966600e9b2dea7513f6c77df499/3891b/day-16.png","srcSet":"/static/c8949966600e9b2dea7513f6c77df499/3ba9f/day-16.png 100w,\n/static/c8949966600e9b2dea7513f6c77df499/8ac63/day-16.png 200w,\n/static/c8949966600e9b2dea7513f6c77df499/3891b/day-16.png 400w,\n/static/c8949966600e9b2dea7513f6c77df499/83db5/day-16.png 531w","sizes":"(max-width: 400px) 100vw, 400px"}}}},"html":"<h1>Description:</h1>\n<p>Dynamic programming technique (memoization) with factorial and Pascal triangle. Dynamic programming is a concept that tends to be quite confusing when it comes to applying it, but memoization (not memorization) is one of the characteristics that identifies it for me. In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.  </p>\n<h3>Problem:</h3>\n<p>Implement pascal's triangle with combinations.</p>\n<h3>Recursive factorial function:</h3>\n<h4>Example:</h4>\n<pre><code>   factorial de 4! =  4*3*2*1*0!\n   0! = 1\n</code></pre>\n<h4>Factorial function with memoization and recursive:</h4>\n<pre><code class=\"language-js\">function factorialDynamic() {\n\n    let cache = new Map();\n\n    return function factorial(n) {\n        if (cache.has(n)) {\n            return cache.get(n)\n        } else {\n            if (n &#x3C;= 1) return 1;\n            cache.set(n, n * factorial(n - 1));\n            return cache.get(n);\n\n    }\n\n}\nconst factorial = factorialDynamic();\n</code></pre>\n<h3>Combinatorial function:</h3>\n<h5>Example:</h5>\n<pre><code>    Function: (P Q) = P! / (Q!-(P-Q)!)\n</code></pre>\n<pre><code class=\"language-js\">function combinatorial(p, q) {\n    return (factorial(p) / (factorial(q) * factorial(p - q)));\n}\n</code></pre>\n<h3>Pascal triangle function:</h3>\n<h5>Example:</h5>\n<pre><code>Combinatorial:\n\nfila          (p q)\n0             (0 0)\n1           (1 0) (1 1)\n2        (2 0) (2 1) (2 2)\n3     (3 0) (3 1) (3 2) (3 3)\n</code></pre>\n<h5>Row function:</h5>\n<pre><code class=\"language-js\">function row(p) {\n\n    let row = [];\n\n    for (let q = 0; q &#x3C;= p; ++q) {\n        row.push(combinatorial(p, q));\n    }\n    return row;\n\n}\n</code></pre>\n<h4>Triangle function (main):</h4>\n<pre><code class=\"language-js\">function trianglePascal(rows) {\n\n    let triangle = [];\n\n    for (let p = 0; p &#x3C; rows; ++p) {\n        triangle.push(row(p))\n    }\n    return triangle;\n}\n</code></pre>\n<h4>Print funtion (test result):</h4>\n<pre><code class=\"language-js\">function print(triangle) {\n\n    for (let row of triangle) {\n        console.log(row);\n    }\n}\n</code></pre>\n<p><code>print(trianglePascal(6));</code></p>\n<pre><code>1              [ 1 ]\n2             [ 1, 1 ]\n3           [ 1, 2, 1 ]\n4         [ 1, 3, 3, 1 ]\n5       [ 1, 4, 6, 4, 1 ]\n6     [ 1, 5, 10, 10, 5, 1 ]\n</code></pre>\n<p>You can check<br>\n<a href=\"https://github.com/difo23/interviewQuestAnsJS\" target=\"_blank\"> code </a> by @difo23   </p>"},"site":{"siteMetadata":{"title":"Lizandro's 100 Days of Code"}}},"pageContext":{"day":"16","title":"Dynamic programming and memoization"}},"staticQueryHashes":["1497828201","63159454"]}